#3D描画アプリケーション(Raytracing Simulator) 最終レポート

##実行結果の確認
###実行方法
- jarファイルをダブルクリックで実行。
- もしくは、ターミナルで`java`コマンドを使用する。
###実行結果
本アプリケーションを起動すると、ウィンドウ左側領域に3D表示領域、右側領域に操作パネルが現れる。
- アプリケーションの起動直後に初期光源が1つ自動配置され、最低限の照明環境が構築されていることを確認。
- WASD+RFキーとマウスを用いたカメラ操作が正しく反映された。
- 複数の異なる形状(球・立方体・三角錐)を同一空間内に配置した際も、形状間のシャドウや反射が正確に描画された。
- 高反射率の物体を連続して配置した際、複雑な多重反射描写が確認できた。
- 設定変更(FPS・品質・背景色)後、即座にレンダリング結果に反映される操作性が実現されている。
- ベンチマークが正しく機能し、CPUの性能によってスコア差が生じた。
- ウィンドウサイズを変更しても描画領域と操作パネルが自動でレイアウト調整され、柔軟なUI構成が実装されている。

###動作速度調査
手持ちの4台のPCで本アプリケーションのベンチマーク機能を動作させ比較検証した。
スコアは5回実行時の平均を取った。CPU使用率はタスクマネージャー及びアクティビティモニタの数値を参照している。
各マシンスペックと、結果を以下に記す。

| CPU                              | GPU                         | RAM              | スコア     | CPU使用率 |
|----------------------------------|-----------------------------|------------------|---------|--------|
| Apple M2 (8C8T)                  | Apple M2 GPU                | 16GB LPDDR5-6400 | 558.32  | 90%前後  |
| AMD Ryzen 9 3900X (12C24T)       | NVIDIA GeForce GTX 1060 3GB | 32GB DDR4-2666   | 785.12  | 95%前後  |
| Intel Core i7 12700K (12C20T)    | NVIDIA GeForce RTX 2060 6GB | 64GB DDR5-4800   | 1118.75 | 100%前後 |
| Intel Core Ultra 9 285K (24C24T) | NVIDIA GeForce RTX 4080     | 128GB DDR5-5200  | 1885.5  | 100%前後 |

####Apple M2の結果
Apple M2は、高効率・低消費電力設計を重視したSoCであり、FP32の純粋な演算性能ではデスクトップCPUに劣る。
LPDDR5の高帯域幅によりメモリアクセスの速度は高いものの、CPU側の演算リソースやマルチスレッド性能が相対的に低く、その影響でスコアは558にとどまっている。
90％という高い使用率からは、ほぼ限界まで活用されているが、性能自体が足りていないことが読み取れる。

####Ryzen 9 3900Xの結果
Ryzen 9 3900Xは12コア24スレッドの多コアCPUであり、並列性の観点からは非常に優れている。
スコアはApple M2の約1.5倍に向上しており、純粋な演算性能が描画性能に直結していることがわかる。
ただし、メモリがDDR4-2666と比較的遅めであるため、一部のメモリアクセスがボトルネックとなっている可能性がある。

####Core i7 12700Kの結果
Alder Lake世代のCore i7は、PコアとEコアのハイブリッド構成を採用しており、シングルスレッドとマルチスレッドのバランスが良い。
スコアは1118とRyzen 9 3900Xを上回っており、これは高クロックかつ高速DDR5メモリの恩恵が大きいと考えられる。
さらに、Intelのスレッドスケジューリング効率が本アプリケーションと相性が良い可能性もある。
CPU使用率は100％と限界まで使用できており、マルチスレッドの恩恵が十分に活かされている。

####Core Ultra 9 285Kの結果
このCPUでは、スコアが1885に到達し、ベンチマーク中は最もfpsが落ち込んだシーンでも18fps程度だったため、実質的にリアルタイムレイトレーシングが実現されている。
最新世代の高性能コア、広いキャッシュ、高速なメモリ帯域、および最新のスレッドスケジューリングによって、最も高い性能を引き出している。
また、メモリが128GBと潤沢で、ガーベジコレクションや一時的なバッファ使用時の余裕も影響している可能性もある。

####全体的な傾向
- macOSよりもWindowsが、Arm系CPUよりもx86系CPUの方が性能を活かせる傾向があると推測する。
- RyzenのCPU使用率が上がりきらなかった理由としては、zenアーキテクチャのメモリ周りの構造上の欠陥が関係している可能性がある。
- ベンチマーク中の様子を見るに、CPUによるリアルタイムレイトレーシングは、現時点では要件が非常に高いと考えられる。

##アプリケーションの操作方法
###カメラの操作方法
キー操作は押下時・長押し時ともに連続入力に対応しており、移動や視点変更のレスポンスが高い。
画面端にカーソルを移動してもマウス入力が外れることなく、常に3D空間への操作が可能。
####カメラ移動
- Wキー: 前へ進む
- Aキー: 左へ進む
- Sキー: 後ろへ進む
- Dキー: 右へ進む
- Rキー: 真上へ進む
- Fキー: 真下へ進む

####カメラ回転
- 左側3D表示領域を左クリックしてドラッグすると、カメラの回転を行う。
- カメラの向きに合わせて、WASD+RFキーを押した時に移動する方向が変わり、ゲームのような直感的な操作を実現している。

###操作パネル
####物体の追加
- ウィンドウ右上のComboBoxにて、物体の種類(立方体, 三角錐, 球, 光源)を選択する。
- テキストフィールドより座標を入力する。
- 大きさ/半径/明るさ を入力する(正の数のみ)。
- 物体の反射率(鏡面反射率)を入力する(0~1.0)。
- 色付きボタンを押すと別途色選択ウィンドウが開くので、そこで色を選択する。
- 「オブジェクトの追加」をクリックすると空間にオブジェクトが追加される。
- 入力値が間違っていた場合、「入力エラー」ダイアログが開く。

####物体の変更(編集)
本アプリケーションは、既存の物体の位置や大きさなどのプロパティを変更できる機能も有している。
- 右下のリストより、編集したい物体を選択する。
- 編集モードに切り替わるので、物体の追加と同様、ComboBoxから順にプロパティを入力する。
- 編集したい物体を選択すると、自動的にその物体のプロパティがテキストフィールドやComboBoxに反映される。
- 「変更を反映」をクリックする。

####物体の削除
- 右下のリストより、削除したい物体を選択する。
- 「選択したオブジェクトを削除」ボタンをクリックすると、物体が削除される。

####物体の全削除
- ウィンドウ右下、「すべて削除」ボタンをクリックすると、確認のダイアログが開く。
- 「はい」を選択すると、全ての物体が削除される。
- 完全に全ての物体が消えるわけではなく、起動直後と同様、光源は1つだけ追加されている状態となる。

####詳細操作
- メニューバー「編集」より詳細な操作がショートカットキーで可能
- 物体の移動
- 物体の拡大・縮小、または光源の明るさ変更
- 形状を変更
- 形状の色をランダムに変更
- カメラの位置、またはカメラの前方に入力座標を設定
- カメラの視点を水平に戻す

####設定
- メニューバー「ファイル」→「設定」をクリックすると、設定ウィンドウが開く。
- 最大フレームレートを5fps刻みで10~60の間で設定できる(初期値30)。
- レンダリング解像度を1/1~1/4の範囲で設定できる(初期値1/1)。これは、描画負荷を軽減する機能であり、1/4に設定した場合、ネイティブ解像度の1/4の解像度でレンダリングした後、ネイティブ解像度に映像を引き延ばす。ただし、画質は悪化する。
- 反射の最大深さを、0~127の間で設定できる(初期値10)。0にすると反射は初回のみとなる。127にすると1本のレイあたり最大127回の反射まで許容する。
- 背景色を設定できる。背景色は、物体の反射にも影響するため、背景色を変更すると見た目が大きく変化する。
- デバッグ情報の表示/非表示を変更できる。デバッグ情報とは、左上に表示されている、CPU使用率やカメラ座標などの情報である。
- これらの設定はアプリを閉じても保存される。

####ベンチマーク機能
- 設定ウィンドウ下部、「ベンチマーク実行」ボタンをクリックするか、メニューバー「ベンチマーク」で開始できる。
- 球50個、三角錐20個、立方体20個、をそれぞれ20秒間ずつレンダリングし、フレーム数がそのままスコアとなる。
- ベンチマークスコアはアプリを閉じても保存される。
- 実際にCPUに依って性能差が生じる。
- ベンチマーク中は操作やボタン入力は不可能となり、ウィンドウサイズは強制的に変更される。
- レンダリング解像度等倍、反射の最大深さ127の最重量級の設定でレンダリングが行われる。

####シーン保存
- メニューバー「ファイル」よりシーンの保存や読み込みができる。
- 上書き保存に対応している。
- ショートカットキーで簡単に保存できる。

####初期化
- メニューバー「ファイル」→「保存されたデータを初期化」より、設定を初期状態に戻し、ベンチマークスコアを全てリセットする。
- 確認ダイアログが表示され、誤って押しても引き返せる設計となっている。

###描画パネル
####レンダリング
- 設定したフレームレートでレンダリングを試みる。
- 非常に高負荷なため、ノートPCでの長時間動作は非推奨である。
- 本アプリへのフォーカスが途切れると、自動的にレンダリングを停止する。
- ⌥option + Pでもレンダリングの停止・再開が可能
####デバッグ情報
- フレームレート、CPU使用率、論理コア数、メモリ使用量やカメラの位置などの情報を表示する。
- CPU使用率はシステム全体の使用率である。
- メモリ使用量は[本アプリが実際に使用中のメモリ/JVMに割り当てられているメモリ]の形式で表示される。

###アピールポイント
####完全自作のリアルタイムCPUレイトレーサー
- Javaの標準API（BufferedImage, Graphics2D, ThreadPoolExecutor等）を活用し、描画・スレッド制御を独自構築。
- 起動時に論理CPU数を自動取得し、環境に応じてスレッド数を最適化する処理を実装。
- 最大127回反射のレイトレーシングを実装
- リアルタイム動作(リアルタイムレイトレーシング)が可能
- CPUのマルチコアを効率的に活用(立方体20個配置によりCPU使用率95％超を記録した)

####マルチスレッド対応(並列レンダリング)
- 行単位で並列レンダリング
- 複雑なスレッド制御ではなく、簡潔かつ効果的な並列化を実現
- CPUリソースを最大限活用し、パフォーマンス最適化

####本格的な物理ベースの鏡面反射
- 各レイは、反射ベクトルを再帰的に計算し、光源到達までの全ての交差オブジェクトを追跡。
- 色の合成は、各反射ごとに減衰係数を掛け合わせ、現実の光エネルギー減衰に近似。

####操作可能なインターフェースを自作
- 物体の種類（球・立方体・三角錐）の選択
- 位置、大きさ、色、反射率をGUIから操作可能

####性能と実用性の両立
- 全画素・全反射について逐次ベクトル計算を行っており、擬似処理やキャッシュは使用していない。
- 実行環境によりフレームレートは変動するが、通常のApple M2チップでも実用的なフレームレートを維持可能。

####描画に関するライブラリ不使用
- OpenGLやVulkan、Metalなどのグラフィックスライブラリは一切使用していない
- UIの見た目のみライブラリを使用
- グラフィックスライブラリ使用などを除けば、本講義最終課題唯一の3D描画ソフトである可能性がある。

####ベンチマーク機能搭載
- ベンチマーク機能を利用し、本アプリケーションの実行速度を数値で具体的に比較することが可能である。

##感想
本アプリケーションの開発を通じて、レイトレーシングの理論から実装、そして最適化・UI統合に至るまで、
3D描画技術に関する幅広い知識と技術力を実践的に習得することができた。
特に難易度が高かったのは、CPUベースでのリアルタイムレイトレーシングの実現に向けた最適化の過程である。
各ピクセルごとの光線追跡処理は非常に高負荷であり、初期段階のシングルスレッド処理では起動直後の段階で4~5fps程度であった。
しかし、行単位でのマルチスレッドレンダリングや、計算量削減を段階的に実施することで、実時間での操作が可能となる水準にまで到達できた点は大きな達成感があった。
また、ユーザーインターフェースの構築においても、単に見た目を整えるだけでなく、「誰でも直感的に操作できる」ことを重視し、GUI設計と例外処理の両面で工夫を凝らした。
今後は、さらなる性能向上のためのアクセラレーション構造（BVH、空間分割)や、屈折・透明といった物理現象の追加、
より高品質なトーンマッピング・ガンマ補正への対応も検討したいと考えている。
本課題を通じて得られた知見は、将来的にGPUベースのリアルタイムレンダリングやゲームエンジン開発など、より大規模なグラフィックス技術への応用にもつながる貴重な財産となった。

